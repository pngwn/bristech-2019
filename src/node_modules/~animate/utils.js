export const is_date = obj =>
	Object.prototype.toString.call(obj) === "[object Date]";

export const is_function = fn => typeof fn === "function";

export const is_equal_length = x =>
	x[0].value
		? x.every(v => x[0].value.length === v.value.length)
		: x.every(v => x[0].length === v.length);

export const get_interpolator = (a, b) => {
	if (a === b || a !== a) return () => a;
	const type = typeof a;

	if (type !== typeof b || Array.isArray(a) !== Array.isArray(b)) {
		throw new Error("Cannot interpolate values of different type");
	}

	if (Array.isArray(a)) {
		const arr = b.map((bi, i) => {
			return get_interpolator(a[i], bi);
		});

		return t => arr.map(fn => fn(t));
	}

	if (type === "object") {
		if (!a || !b) throw new Error("Object cannot be null");

		if (is_date(a) && is_date(b)) {
			a = a.getTime();
			b = b.getTime();
			const delta = b - a;
			return t => new Date(a + t * delta);
		}

		const keys = Object.keys(b);
		const interpolators = {};

		keys.map(key => {
			interpolators[key] = get_interpolator(a[key], b[key]);
		});

		return t => {
			const result = {};
			keys.map(key => {
				result[key] = interpolators[key](t);
			});
			return result;
		};
	}

	if (type === "number") {
		const delta = b - a;
		return t => a + t * delta;
	}

	throw new Error(`Cannot interpolate ${type} values`);
};

export const createAnimation = options => (value, i, arr) => ({
	value,
	duration: is_function(options.duration)
		? options.duration(i, arr.length, value)
		: options.duration,
	delay: is_function(options.delay)
		? options.delay(i, arr.length, value)
		: options.delay,
	easing: options.easing,
	reverse_easing: options.reverse_easing,
});
