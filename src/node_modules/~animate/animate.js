import { writable } from "svelte/store";
import { assign, loop, now } from "svelte/internal";
import { linear } from "svelte/easing";
import { is_function, get_interpolator, createAnimation } from "./utils.js";

const handle_value = (val, defaults) =>
	val.to
		? val.to.map(createAnimation(defaults))
		: val.map(createAnimation(defaults));

export const animation = (value, defaults = {}) => {
	let stop = false;
	if (!value.to && defaults.autoplay) {
		/* eslint-disable-next-line no-console */
		console.warn("Cannot autoplay animations without a 'to' value");
		defaults.autoplay = false;
	}

	const store = writable(value.from ? value.from : value, () => () =>
		(stop = true),
	);

	defaults = assign(
		{
			delay: 0,
			duration: 400,
			easing: linear,
			interpolate: get_interpolator,
			alternate: false,
			repeat: false,
			autoplay: false,
		},
		defaults,
	);

	let task,
		target_value = handle_value(value, defaults),
		old_value = value.from ? value.from : value,
		v = old_value;

	const set = (new_value, opts) => {
		if (!new_value && !target_value) {
			throw new Error(
				"Either initialise the animation with a 'to' value or call set with a 'to' value'.",
			);
		}

		const options = assign(assign({}, defaults), opts);
		old_value = v;
		target_value = new_value ? handle_value(new_value, options) : target_value;

		let previous_task = task;
		let started = false;

		const start = now();
		let meta;

		task = loop(now => {
			if (now < start) return true;

			if (!started) {
				// instead of running interpolators on every frame or using some other heuristic
				// we will calculate forwards and backwards interpolators once per run
				// same for delays and durations
				meta = target_value.map(
					({ value, duration: localDuration, delay }, i) => ({
						forwards: options.interpolate(old_value[i], value),
						backwards:
							options.alternate && options.interpolate(value, old_value[i]),
						forwardsDuration:
							localDuration && is_function(localDuration)
								? localDuration(old_value[i], value)
								: localDuration
								? localDuration
								: options.duration,
						backwardsDuration:
							options.alternate && localDuration && is_function(localDuration)
								? localDuration(value, old_value[i])
								: localDuration
								? localDuration
								: options.duration,
						delay,
					}),
				);
				started = true;
			}

			const elapsed = now - start;

			const values = meta.map(
				({ forwards, backwards, delay, forwardsDuration }, i) => {
					const dirF = ((elapsed - delay) / forwardsDuration) % 2 < 1;
					const isDone =
						!options.repeat &&
						(elapsed - delay) / forwardsDuration > (options.alternate ? 2 : 1);
					const t_value = target_value[i].value
						? target_value[i].value
						: target_value[i];

					return {
						isDone,
						progress:
							(elapsed - delay) % (dirF ? forwardsDuration : forwardsDuration),
						from: forwards ? old_value[i] : t_value,
						to: isDone
							? options.alternate
								? old_value[i]
								: t_value
							: dirF
							? old_value[i]
							: t_value,
						fn: !options.alternate || dirF || !backwards ? forwards : backwards,
						delay: delay ? delay : options.delay,
						duration: forwardsDuration,
					};
				},
			);

			if (previous_task) {
				previous_task.abort();
				previous_task = null;
			}

			if (stop) {
				store.update(v => v);
				return false;
			}

			if (values.every(({ isDone }) => isDone)) {
				store.set((v = values.map(v => v.to)));
				return false;
			}

			store.set(
				(v = values.map(({ fn, duration, from, to, progress, isDone }) => {
					if (isDone) return to;
					if (progress < 0) return from;
					return fn(options.easing(progress / duration));
				})),
			);
			return true;
		});

		return task.promise;
	};

	if (defaults.autoplay) {
		set();
	}

	return {
		stop: () => (stop = true),
		set,
		update: (fn, opts) => set(fn(target_value, value), opts),
		subscribe: store.subscribe,
	};
};
